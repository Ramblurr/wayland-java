/*
 * Copyright Â© 2014 Erik De Rijcke
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting documentation, and
 * that the name of the copyright holders not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  The copyright holders make no representations
 * about the suitability of this software for any purpose.  It is provided "as
 * is" without express or implied warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
 * OF THIS SOFTWARE.
 */
package org.freedesktop.wayland.client;

import com.sun.jna.Pointer;

import org.freedesktop.wayland.client.jna.WaylandClientLibrary;
import org.freedesktop.wayland.client.jna.wl_proxy;
import org.freedesktop.wayland.util.Arguments;
import org.freedesktop.wayland.util.Dispatcher;
import org.freedesktop.wayland.util.InterfaceMeta;
import org.freedesktop.wayland.util.ObjectCache;
import org.freedesktop.wayland.util.WaylandObject;
import org.freedesktop.wayland.util.jna.wl_argument;
import org.freedesktop.wayland.util.jna.wl_object;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.util.HashMap;
import java.util.Map;

/**
 * Represents a protocol object on the client side.
 * <p>
 * A {@code Proxy} acts as a client side proxy to an object existing in the
 * compositor. The proxy is responsible for converting requests made by the
 * clients with {@link #marshal(int)} into Wayland's wire format. Events
 * coming from the compositor are also handled by the proxy, which will in
 * turn call the implementation.
 * <p>
 * With the exception of function {@link #setQueue(EventQueue)}, functions
 * accessing a {@code Proxy} are not normally used by client code. Clients
 * should normally use the higher level interface generated by the scanner to
 * interact with compositor objects.
 * <p>
 *
 * @param <I> Implementation type that will act as the listener for received events.
 */
public abstract class Proxy<I> implements WaylandObject {

    private static final Map<Class<? extends Proxy<?>>, Constructor<? extends Proxy<?>>>
            PROXY_CONSTRUCTORS =
            new HashMap<Class<? extends Proxy<?>>, Constructor<? extends Proxy<?>>>();

    private final wl_proxy pointer;
    private final int  version;
    private final I implementation;

    private final Dispatcher dispatcher;

    /**
     * @param pointer
     * @param implementation The listener to be added to proxy
     * @param version
     */
    protected Proxy(final wl_proxy pointer,
                    final I implementation,
                    final int version) {
        this.pointer = pointer;
        this.implementation = implementation;
        this.version = version;
        ObjectCache.store(getNative().getPointer(),
                          this);
        //Special casing implementation. For some proxies the underlying native library provides its own implementation.
        //We pass in a null implementation in those cases. (Eg Display proxy).
        if (implementation != null) {
          dispatcher = new Dispatcher(this);
          WaylandClientLibrary.INSTANCE.wl_proxy_add_dispatcher(this.pointer,
                                                                this.dispatcher,
                                                                Pointer.NULL,
                                                                Pointer.NULL);
        }else{
          dispatcher = null;
        }
    }

    public int getVersion() {
        return this.version;
    }

    //called from generated proxies

    /**
     * Prepare a request to be sent to the compositor
     * <p>
     * This function is similar to {@link #marshalConstructor(int, Object, int, Class, Arguments)}, except
     * it doesn't create proxies for new-id arguments.
     * <p>
     * This should not normally be used by non-generated code.
     *
     * @param opcode Opcode of the request to be sent
     * @param args   Extra arguments for the given request
     */
    protected void marshal(final int opcode,
                           final Arguments args) {
        marshal(opcode,
                args.getNative());
    }

    //called from generated proxies
    /**
     * @param opcode Opcode of the request to be sent
     * @see {@link #marshal(int, Arguments)}
     */
    protected void marshal(final int opcode) {
        marshal(opcode,
                new wl_argument[]{new wl_argument(Pointer.NULL)});
    }

    //called from generated proxies
    protected void marshal(final int opcode,
                           final wl_argument[] argsPointer) {
        WaylandClientLibrary.INSTANCE.wl_proxy_marshal_array(this.pointer,
                                                             opcode,
                                                             argsPointer[0]);
    }

    //called from generated proxies
    /**
     * Prepare a request to be sent to the compositor
     * <p>
     * Translates the request given by opcode and the extra arguments into the
     * wire format and write it to the connection buffer.
     * <p>
     * For new-id arguments, this function will allocate a new {@code Proxy}
     * and send the ID to the server.  The new {@code Proxy} will be returned
     * on success or NULL on errror with errno set accordingly.
     * <p>
     * This is intended to be used by language bindings and not in
     * non-generated code.
     *
     * @param opcode         Opcode of the request to be sent
     * @param implementation The listener to use for the new proxy
     * @param version        The runtime version of the new proxy
     * @param newProxyCls    The type to use for the new proxy
     * @param args           Extra arguments for the given request
     * @param <J>            implementation Type
     * @param <T>            proxy Type
     * @return a new proxy
     */
    protected <J, T extends Proxy<J>> T marshalConstructor(final int opcode,
                                                           final J implementation,
                                                           final int version,
                                                           final Class<T> newProxyCls,
                                                           final Arguments args) {
        return marshalConstructor(opcode,
                                  implementation,
                                  version,
                                  newProxyCls,
                                  args.getNative());
    }

    //called from generated proxies
    protected <J, T extends Proxy<J>> T marshalConstructor(final int opcode,
                                                           final J implementation,
                                                           final int version,
                                                           final Class<T> newProxyCls,
                                                           final wl_argument[] argsPointer) {
        try {
          final wl_proxy
              wlProxy =
              WaylandClientLibrary.INSTANCE.wl_proxy_marshal_array_constructor(this.pointer,
                                                                               opcode,
                                                                               argsPointer[0],
                                                                               InterfaceMeta.get(newProxyCls)
                                                                                   .getNative());
          return marshalProxy(wlProxy,
                                implementation,
                                version,
                                newProxyCls);
        }
        catch (final NoSuchMethodException e) {
            throw new RuntimeException("Uh oh, this is a bug!",
                                       e);
        }
        catch (final IllegalAccessException e) {
            throw new RuntimeException("Uh oh, this is a bug!",
                                       e);
        }
        catch (final InvocationTargetException e) {
            throw new RuntimeException("Uh oh, this is a bug!",
                                       e);
        }
        catch (final InstantiationException e) {
            throw new RuntimeException("Uh oh, this is a bug!",
                                       e);
        }
    }

    protected <J, T extends Proxy<J>> T marshalProxy(final wl_proxy pointer,
                                                     final J implementation,
                                                     final int version,
                                                     final Class<T> newProxyCls) throws NoSuchMethodException,
            IllegalAccessException,
            InvocationTargetException,
            InstantiationException {
        Constructor<? extends Proxy<?>> proxyConstructor = PROXY_CONSTRUCTORS.get(newProxyCls);
        if (proxyConstructor == null) {
            proxyConstructor = findMatchingConstructor(newProxyCls,
                                                       long.class,
                                                       implementation.getClass(),
                                                       int.class);
            PROXY_CONSTRUCTORS.put(newProxyCls,
                                   proxyConstructor);
        }
        return (T) proxyConstructor.newInstance(pointer,
                                                implementation,
                                                version);
    }

    protected <J, T extends Proxy<J>> Constructor<T> findMatchingConstructor(Class<T> newProxyCls,
                                                                             Class<?> longClass,
                                                                             Class<?> implementationClass,
                                                                             Class<?> intClass) throws NoSuchMethodException {
        for (Constructor<?> constructor : newProxyCls.getConstructors()) {
            final Class<?>[] parameterTypes = constructor.getParameterTypes();
            if (parameterTypes.length != 3) {
                continue;
            }
            if (parameterTypes[0].isAssignableFrom(longClass) &&
                    parameterTypes[1].isAssignableFrom(implementationClass) &&
                    parameterTypes[2].isAssignableFrom(intClass)) {
                return (Constructor<T>) constructor;
            }
        }
        throw new NoSuchMethodException();
    }

    /**
     * Destroy a proxy object
     */
    public void destroy() {
      WaylandClientLibrary.INSTANCE.wl_proxy_destroy(this.pointer);
        ObjectCache.remove(getNative().getPointer());
    }

    /**
     * Get a proxy's listener
     * <p>
     * Gets the proxy's listener; which is the implementation set when this proxy was constructed.
     * <p>
     * This function is useful in client with multiple listeners on the same
     * interface to allow the identification of which code to execute.
     *
     * @return The proxy's listener or NULL if no listener is set
     */
    public I getImplementation() {
        return this.implementation;
    }

    /**
     * Get the id of a proxy object
     *
     * @return The id the object associated with the proxy
     */
    public int getId() {
        return WaylandClientLibrary.INSTANCE.wl_proxy_get_id(this.pointer);
    }

    /**
     * Assign a proxy to an event queue
     * <p>
     * Assign proxy to event queue. Events coming from {@code proxy} will be
     * queued in {@code queue} instead of the display's main queue.
     *
     * @param queue The event queue that will handle this proxy
     * @see Display#dispatchQueue(EventQueue)
     */
    public void setQueue(final EventQueue queue) {
      WaylandClientLibrary.INSTANCE.wl_proxy_set_queue(this.pointer,
                                                       queue.getNative());
    }

    public wl_object getNative(){
      return new wl_object(this.pointer.getPointer());
    }

    @Override
    public boolean equals(final Object o) {
        if (this == o) {
            return true;
        }
        if (!(o instanceof Proxy)) {
            return false;
        }

        final Proxy proxy = (Proxy) o;

        return getNative().equals(proxy.getNative());
    }

    @Override
    public int hashCode() {
        return getNative().hashCode();
    }
}